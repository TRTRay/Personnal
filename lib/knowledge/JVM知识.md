# JVM知识

[TOC]

## JVM类文件结构





## JVM类加载过程

![类加载过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png)

<center style = "color:#C0C0C0">类加载过程</center>

类加载过程是指将Class文件加载到JVM中

类加载过程主要有加载、连接、初始化；其中连接包括验证、准备、解析三个过程



### 加载

==加载阶段查找用来定义类的二进制字节流，并在内存中创建class对象==

加载阶段主要完成：

- 通过全类名获取定义此类的二进制字节流
- 将字节流代表的静态存储结构转换成方法区的运行时数据结构
- 在内存中生成一个代表该类的Class对象作为方法区这些数据的访问入口



虚拟机规范对上面3点并不明确，因此加载过程是非常灵活的，例如并没有具体指出从哪里加载定义类的二进制流，常见的有从ZIP包（JAR、EAR、WAR）中获取、其他文件生成（JSP）

一个非数组类加载获取二进制字节流的动作是可控性最强的阶段，可以通过默认方式完成，以科技自定义类加载器来控制字节流的获取方式（重写一个类加载器的loadClass()方法）；数组类型不通过类加载器创建，由Java虚拟机直接创建

**加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能已经开始了**



### 连接

#### 验证

==验证阶段确保加载的字节码是合法、合理并且符合Java规范的==

![验证阶段示意图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png)

<center style = "color:#c0c0c0">验证阶段</center>

#### 准备

==准备阶段正式为静态变量分配内存并设置初始值==，这些内存都在方法区中分配



注意几点：

- 这时候进行内存分配的仅包括类变量（又叫静态变量，static）；实例变量会在对象实例化时随着对象一块分配在Java堆中

- 这里的初始值并不是代码中对变量初始化设置的值，而是指初始化为默认值，例如对于

  ```java
  public static int value = 111;
  ```

  value在准备阶段的初始值是0，在初始化阶段是111

  但是如果为value变量加上final关键字，在准备阶段value就被设置为111，这是因为在编译class文件的时候生成了一个constantValue属性，在类的加载阶段直接把constantValue的值赋给了变量



#### 解析

==解析阶段将常量池内的符号引用替换为直接引用==，也就是得到类、接口、字段、方法等在内存中的指针或偏移量



符号引用就是一些字面量的引用，是人为规定的，和实际数据结构、内存都没有关系；JVM为每个类都准备了一张方法表，当需要使用某个方法的时候只需要知道该方法在方法表中的偏移量即可；也就是说，解析阶段将符号印尼用转变成目标方法在方法表中的位置，从而可以成功调用该方法



### 初始化

==初始化阶段为静态变量赋值==



初始化阶段是执行类构造器<kbd>clint()</kbd>方法的过程，在这一阶段，类才能顺利装在到系统中，才开始执行类中定义的Java程序代码

关于线程安全：clinit()方法是带锁线程安全的，JVM会确保自己在多线程环境中的安全性，因此在多线程环境下进行类的初始化可能会引起死锁，并且这种死锁很难被发现

JVM严格规范了只有以下5中情况必须对类进行初始化：

- 当遇到new、getstatic、putstatic、invokestatic这4条直接码指令时，例如new一个对象、读取一个未被final修饰的静态字段或调用一个静态方法时
- 使用java.lang.reflect包的方法对类进行反射调用时，如果类未初始化，需要先触发其初始化
- 初始化一个类，如果其父类未初始化，则先触发该父类的初始化
- 当虚拟机启动时，需要先对主类（带main()方法的类）进行初始化
- 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。



## JVM类加载器

类加载器是在类加载过程的加载阶段，将calss类加载到内存中



JVM中内置了三个重要的类加载器，分别是

- BootstrapClassLoader（启动类加载器）
- ExtensionClassLoader（扩展类加载器）
- AppClassLoader（应用程序类加载器）

除了BootstrapClassLoader之外都是继承自java.lang.ClassLoader

自定义的类加载器也必须继承ClassLoader类



### 双亲委派模型

![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)

<center style = "color:#c0c0c0">ClassLoader</center>

**不熟**





## 运行时数据区

相对于C/C++，Java将内存控制权交给了JVM，在JVM的内存管理机制下不需要程序员手动进行释放内存等操作，不容易出现内存泄漏和溢出方面的问题



JVM在执行程序的过程中会将管理的内存划分为几个不同的数据区域

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

<center style = "color:#c0c0c0">JDK 1.8之前</center>

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

<center style = "color:#c0c0c0">JDK 1.8</center>

直接内存是非运行时数据区的一部分，是线程共享的



### 程序计数器

程序计数器是一块较小的内存区域，可以看作是当前线程执行的字节码的行号指示器，==程序计数器指示了下一条即将执行的指令的行号==。字节码解释器工作时通过改变计数器的值来选取下一条字节码指令，因此分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器完成



为了线程切换后能够回到正确的执行位置，每条线程都有一个独立的程序计数器，各线程之间计数器互不影响；线程的程序计数器独立存储，这一类内存区域被称为“线程私有”的内存



程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，他的生命周期随着线程创建和结束



### Java虚拟机栈

==Java虚拟机栈描述的是Java方法执行的内存模型==，每一次函数调用都会有一个对应的栈帧被压入栈中，函数调用结束后栈帧弹出，每次方法调用的数据都是通过栈传递的

Java虚拟机栈也是“线程私有”的，他的生命周期与线程相同



虚拟机栈由一个个栈帧组成，每个栈帧中都有局部变量表、操作数栈、动态链接、方法出口信息



在讨论Java内存的时候经常提到“堆内存”和“栈内存”，其中栈内存就是指虚拟机栈，更确切点应该是虚拟机栈中的局部变量表部分；局部变量表主要存放了编译器创建的各种数据类型、对象引用



Java虚拟机栈可能出现两种异常：

- StackOverFlowError：在Java虚拟机栈的内存大小不允许动态扩展时，当线程请求的栈深度超过最大深度就会抛异常
- OutOfMemoryError：在Java虚拟机栈的内存大小允许动态扩展时，当线程请求的栈内存用完，无法进行动态扩展就会抛异常



### 本地方法栈

本地方法栈的作用与虚拟机栈发挥的作用非常相似，区别在于：

虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为虚拟机使用Native方法服务



> Native方法

Native方法就是本地方法，简单来说就是，一个Java程序要使用其他代码编写的程序接口



在HotSpot虚拟机中，Java虚拟机栈与本地方法栈合二为一



### 堆

==堆的唯一作用是存放对象实例，几乎所有对象实例和数组都在这里分配内存==

Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，是虚拟机管理的内存中最大的一块

Java堆也是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collection Heap）

从垃圾回收的角度来说，现在的垃圾收集器基本都采用分代垃圾回收算法，Java堆可以细分为新生代和老年代，更细致的划分见下图即可，==进一步划分的目的是更好的回收内存和更快的分配内存==

JDK 7之前堆内存常被分成：新生代，老生代，永生代三个部分

![JVM堆内存结构-JDK7](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.jpg)

<center style = "color:#c0c0c0">JDK 7堆内存结构</center>

在之后的版本中，HotSpot永生代被永久移除，取而代之的是使用直接内存的元空间

![JVM堆内存结构-JDK8](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.jpg)

<center style = "color:#c0c0c0">JDK 8堆内存结构</center>

堆最容易出现的是OutOfMemoryError异常，并且这种异常有很多种表现形式



### 方法区

==Java方法区被用作存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码==，也是线程共享的区域



> 方法区和永久代的关系

Java虚拟机规范规定了有方法区这个概念，但是并没有规定如何实现 ，对于不同的JVM，方法区的实现肯定不同。永久代是HotSpot虚拟机中的概念，是HotSpot对方法区这一概念的一种实现



### 运行时常量池

==运行时常量池是方法区的一部分==，Class文件中除了有类的版本、字段、方法、接口等描述信息外还有常量池信息（用于存放编译器生成的各种字面量和符号引用）

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/26038433.jpg)

<center style = "color:#c0c0c0">运行时常量池</center>

当内存请求不到的时候也会怕抛出OutOfMemoryError异常

JDK 8将运行时常量池从方法区中移出来，在堆中开辟了一块内存来存放运行时常量池



### 直接内存

直接内存并不是运行时数据区的部分，也不是JVM规范定义的内存区域，但是这部分内存被频繁的使用，而且也可能会导致OutOfMemoryError出异常现



## HotSpot虚拟机

### Java对象的创建过程

![Java创建对象的过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png)

<center style = "color:#c0c0c0">Java对象的创建过程</center>

#### Step 1:类加载检查

当虚拟机遇到一条new指令时，首先会检查常量池尝试定位该类的符号引用，并检查该类是否已经过类加载过程



#### Step 2:分配内存

JVM在堆中为对象分配一块确定大小（大小在类加载完成后就可以确定了）的内存空间



> 内存分配的分配方式

==内存分配方式有**指针碰撞**和**空闲列表**两种，选择哪种分配方式由Java堆是否规整决定，Java堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定；Java堆是否规整取决于垃圾收集器的算法是“标记-清除”的还是“标记-整理”的（又叫“标记-压缩”）==

- 指针碰撞

指针碰撞适用于Java堆规整的情况

原理是将使用过的内存放在一边，空闲的放在另一边，中间是一个分界值指针，使用的时候将指针向空闲内存的方向移动相应的大小即可

GC收集器：Serial、ParNew



- 空闲列表

空闲列表适用于Java堆不规整的情况

虚拟机维护一个列表，列表记录了哪些内存块是可用的，分配内存时选一块足够大的内存块分配给对象实例，然后更新列表

GC收集器：CMS



> 内存分配的并发问题

在实际开发过程中，创建对象是频繁操作，JVM必须要保障线程安全，通常也有两种方式

- CAS+失败重试：CAS是乐观锁的一种实现方式，乐观锁是指每次不加锁，假设没有冲突而去完成某项操作，如果发生冲突就失败重试，直到成功为止，JVM通过CAS和失败重试的方法保证更新操作的原子性
- TLAB：为每一个线程现在Eden区分配一块内存，JVM在为线程中的对象分配内存时，现在TLAB中分配，当对象大小大于TLAB的剩余内存，或是TLAB内存耗尽，在采用上述CAS进行内存分配



#### Step 3:初始化零值

内存分配完成后，JVM将分配到的内存空间初始化为零值（默认值），这一步确保了实例对象在不赋初始值的情况下就能使用



#### Step 4:设置对象头

初始化零值后，JVM要对对象进行一些必要的设置，例如==该对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息==。这些信息存放在对象头中，另外根据虚拟机当前运行状态的不同，对行头也会有不同的设置方式



#### Step 5:执行init()方法

==将对象按照Java代码中的初始化要求进行初始化==，从虚拟机的角度来看一个新的对象已经生成了，但从Java程序来看，所有字段都还是零值



### Java对象的内存布局

在HotSpot虚拟机中，对象在内存中的布局分为三块：对象头、实例数据、对齐填充

- 对象头：包括两部分信息，一部分是对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志等）；另一部分是类型指针，指向所属类元数据的指针，虚拟机通过指针确定该对象是哪个类的实例
- 实例数据：存储对象的有效信息，就是在Java程序中定义的各个类型的字段内容
- 对齐填充：对齐填充无特别含义，仅展占位作用。因为HotSpot虚拟机的内存管理系统要求对象的大小必须是8字节的整数倍，对象头的大小正好是8字节的1-2倍，因此在实例数据部分没对齐时通过对齐填充补全



### Java对象的访问定位

Java对象的访问方式由虚拟机的实现而定，目前主流的访问方式有**使用句柄**和**直接指针**两种

- 句柄



![对象的访问定位-使用句柄](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png)

<center style = "color:#c0c0c0">对象的访问定位-使用句柄</center>

Java堆中划分出一块内存作为句柄池，引用变量（reference）存储的就是对象的句柄地址，而句柄中则包含了对象实例数据和类型数据信息的地址



- 直接指针

![对象的访问定位-直接指针](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png)

<center style = "color:#c0c0c0">对象的访问定位-直接指针</center>

使用直接指针时，在对象的内存布局中就必须考虑到如何防止类型数据的相关信息，引用变量（reference）存储的就是对象的地址



两种方法各有优劣：

- 使用句柄的好处是，引用变量存储的时是稳定的句柄地址，对象被移动时只改变句柄中实例数据的指针
- 使用直接指针的好处是，速度快，节省了一次指针定位的时间



### String类和常量池

String类的两种创建

- 在常量池中获取对象的引用

  ```java
  String str = "string";
  ```

- 在堆空间创建一个新的对象

  ```java
  String str = new String("string");
  ```



在下面的代码中

```java
String s = new String("string");
```

会创建1-2个String对象，如果常量池中没有“string"对象，会先在常量池中创建，然后在堆中创建一个新的对象



字符串拼接

```java
String s1 = "str";
String s2 = "int";

String s3 = "str" + "ing";	//在常量池创建新的对象
String s4 = s1 + s2;	//在堆上创建新的对象
```



## JVM GC

==Java内存自动管理主要针对对象内存的分配和对象内存的回收，对核心的功能时堆内存的分配与回收==

基于收集器常用的分代垃圾收集算法，Java堆细分为新生代和老年代，进一步细分就是Eden空间、From-Survivor、To-Survivor、Tentired等，==进一步划分的目的是更好的回收或更快的分配内存==

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%A0%86%E7%BB%93%E6%9E%84.png)

<center style = "color:#c0c0c0">堆空间的结构</center>

> Minor GC：新生代GC
>
> Minor GC非常频繁，回收速度一般也比较快

> Major GC/Full GC：老年代GC
>
> Major GC经常会伴随至少一次Minor GC，Major GC的速度一般会比Minor GC慢10倍以上



### GC过程

- 大部分情况下，对象首先在Eden区域分配，对象从Eden区域进入s0之后初始年龄变为1
- 在经历一次新生代GC后，若对象存活，从s0入s1且年龄加1
- 此时Eden区域和s0都为空，将达到一定年龄（阈值可以设置）的对象晋升老年代随后将s0与s1调换
- Minor GC一直重复这样的过程直到s1被填满时将所有对象移动到老年代



### 内存分配策略

主流的垃圾收集器都采用分代回收算法，根据各个年代的特带选择合适的垃圾回收算法

堆内存常见的分配策略

- 对象优先在Eden区进行分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代



#### 对象优先在Eden区进行分配

大多数情况下对象会在新生代Eden区域中进行分配，Eden区域中没有足够内存时，虚拟机将发起一次Minor GC



> 内存分配担保机制

内存分配管理机制是指老年代在每次Minor GC之前检查老年代是否有足够的空间容纳新生代中的所有对象



新生代进行一次Minor GC后如果有足够的区域分配给新的对象，则进行内存分配，如果没有，就将新生代中的所有对象通过复制算法转移到老年代，这也是为什么会有内存分配担保机制



#### 大对象直接进入老年代

大对象是指需要大量连续内存空间的对象

直接进入老年代是为了避免因为内存分配担保机制要对大量的对象进行复制而降低效率



#### 长期存活的对象进入老年代

虚拟机给每个对象设一个对象年龄计数器，每经历过一次就增加1岁，当年龄达到阈值就会晋升到老年代

晋升到老年代的年龄阈值可以通过参数-XX:MaxTurningThreshold来设置



#### 动态对象年龄判断

为了更好适应不同程序的内存情况，当Survivor空间内某个年龄所有对象大小总和超过Survivor空间的一半，就将大于等于该年龄的对象直接晋升到老年代



### 判断对象是否死亡

垃圾回收的对象是那些已经不能再被任何途径使用的对象，即对象已将死亡

#### 判断方法

##### 引用计数法

引用技术法是为每个对象添加一个引用计数器，每当有一个地方引用到他计数器加一；直到计数器归零则表示对象不会再被使用；这样的方式实现简单，效率也高，但是==很难解决循环引用==的问题



##### 可达性分析法

算法的基本思想是，从一系列称为“GC Roots”的对象作为起点，从这些节点向下搜索，节点走过的路径被称为引用链，当一个对象没有引用链能够到达GC Roots时，说明对象是不会再使用的。



#### 引用

将对象的存活与“引用”直接关联；引用可以粗略地理解为一个引用类型的值是一块内存地址的起始地址，引用可以分为**强引用、软引用、弱引用、虚引用**（引用强度逐渐减弱）

##### 强引用（Strong Reference）

大部分引用实际上都是强引用，例如我们常用的new来创建对象等

当内存空间不足时，JVM一定==不会靠回收强引用对象的内存来解决内存不足的问题==，而是宁可抛出内存溢出异常

只用当强引用的那个引用不存在了的时候，JVM才可能回去回收那个对象（比如，某个方法中new了一个对象，引用类型在本地方法栈中，但是对象在堆中，当方法结束时引用变量不存在了，但是对象还在堆中，JVM才去回收）



##### 软引用（SoftReference）

当内存空间足够时，系统不会对软引用进行回收，当内存空间不足时就会回收，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以用来实现内存敏感的高速缓存（打个比方，现在有一个大小相对较大的内容，将其存在软引用中能够提高对这部分内容的访问效率，但是当内存不够时就会将这部分空间回收，如果再次对这部分内容进行访问时，就需要重新加载，和缓存的概念是很相似的；一个更具体地例子是浏览器地返回功能）



##### 弱引用（Weak Reference）

弱引用和软引用的区别在于：**弱引用具有更短的生命周期**

在垃圾回收器线程对内存区域进行扫描时一旦发现只具有弱引用的对象，无论当前内存是否足够，都会回收其内存

但是值得一提的是垃圾收集器线程的优先级都比较低，因此不会很快发现那些只具有软引用的对象



##### 虚引用（Phantom Reference）

虚引用不会决定对象的生命周期，如果一个对象只具有虚引用，那么他和没有引用一样，在任何时候都可能被回收

==虚引用主要用来跟踪对象被垃圾回收的活动==



引用队列？？？？？？？？？？？？？？？？？



#### 对于不可达对象的回收

不可达对象并非非死不可，对于不可达对象，他们会暂时处在“缓刑状态”，要宣告一个对象真正死亡需要经历两次标记；不可达对象在第一次被标记时，若finalize方法未被覆写，或finalize方法已被调用时，JVM会将其放在一个队列中，当队列中的对象被二次标记时，除非该对象通过引用链与存活对象建立关联，否则就真的会被回收



#### 判断一个类是无用的类

对于同时满足下面3个条件的类：

- 该类的所有实例都已经被回收，Java堆中不存在任何该类的实例
- 加载该类的类加载器已被回收
- 该类对应的对象没有在任何地方被引用，也无法在任何地方通过反射访问该类

JVM认为其时无用的类，**可以**对其进行回收，但并不是一定就会回收



### 垃圾收集算法

#### 标记-清除算法

该算法分为“标记“和”清除“两个阶段：

标记阶段标记处所有需要清除的对象（已死亡）

标记完成后统一回收所有被标记的对象



标记-清除算法是最基础的收集算法，后续算法都是针对其不足进行改进的

该算法主要有两个问题：

- 效率问题

- 空间问题（标记清除后会产生大量不连续的碎片）

  <img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg" alt="公众号" style="zoom: 50%;" />

<center style = "color:#c0c0c0c0">标记-清除算法</center>

#### 复制算法

复制收集算法是为了解决效率问题

首先将内存分为大小相同的两块，每次使用其中一块

当一块内存使用完后，将存活的对象复制到另一半

最后将使用过的一半一次性清空



复制收集算法每次进行内存回收针对的都是内存区间的一半

#### 标记-整理算法

标记-整理算法是根据老年代的特点提出的一种标记算法，分为”标记“和”整理“两个阶段

标记阶段标记出所有可回收的对象

标记完成后将所有存活的对象向一段移动，最后清理掉边界以外的内存

<img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg" alt="标记-整理算法 " style="zoom:80%;" />

<center style = "color:#c0c0c0">标记-整理算法</center>

#### 分代收集算法

当前JVM的垃圾回收都采用分代垃圾回收算法，根据对象的存活期不同将内存分为几块然后根据各个年代的特点选择不同的垃圾收集算法

例如，在新生代中，每次进行内存回收都会有大量的对象死去，所以可以选择复制算法来提高效率，只需要付出少量对象的复制成本即可；而老年代的对象存活率较高，又没有额外空间进行分配担保，所以可以选择标记-清除算法或是标记-整理算法



### 垃圾收集器

垃圾收集算法是内存回收的方法，垃圾收集器就是内存回收的具体实现

垃圾收集器有很多种类，要根据具体的应用场景选择适合自己的收集器

![垃圾收集器分类](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg)

<center style = "color:#c0c0c0">垃圾收集器分类</center>

#### Serial收集器

Serial收集器（串行收集器）是一种==单线程收集器==

- 该收集器只有一条垃圾收集线程来完成垃圾收集工作
- 并且==在进行垃圾收集工作的过程中必须暂停所有其他线程，直到收集工作结束==
- 新生代采用复制算法，老年代采用标记-整理算法
- 相比于其他收集器，Serial简单而高效，节省了线程交互的开销
- Serial是收集器对于运行在Client模式下的虚拟机来说

![ Serial 收集器 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/46873026.jpg)

<center style = "color:#c0c0c0">Serial收集器</center>

#### ParNew收集器

ParNew收集器就是==串行收集器的多线程版本==

- 除了使用多线程来完成垃圾收集工作外，其余行为和Serial一样

- 新生代采用复制算法，老年代采用标记-整理算法
- ==除了Serial收集器只有ParNew收集器能与CMS收集器（真正意义上的并发收集器）配合工作==

![ParNew 收集器 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg)

<center style = "color:#c0c0c0">ParNew收集器</center>

ps：有关并行和并发

- 并行（Parallel）：指多条工作线程一起工作，但其他用户线程仍处于等待状态
- 并发（Concurrent）：用户线程与工作线程在两个CPU上运行

#### Parallel Scavenge收集器

Parallel Scavenge与ParNew非常相似

- **该收集器的关注点是吞吐量**（高效利用CPU），CMS等其他收集器的关注点更过是用户线程的停顿时间
- 收集器提供了很多参数来让用户找到最合适的停顿时间和最大吞吐量
- 新生代采用复制算法，老年代采用标记-整理算法

#### Serial Old收集器

Serial收集器的老年代版本，同样是一个单线程收集器，作用主要是：

- 在JDK1.5之前与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备方案

#### Parallel Old收集器

Parallel Scavenge收集器的老年代版本

- 使用多线程和标记-整理算法
- 在注重吞吐量和CPU资源的场合都可以优先考虑Parallel Scavenge和Parallel Old

#### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种==以获取最短回收停顿时间为目标==的收集器

- 非常适合适合应用于注重用户体验的应用上

- 使用的是标记-清除算法

![CMS 垃圾收集器 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg)

<center style = "color:#c0c0c0">CMS垃圾收集器</center>

CMS收集器的运作过程：

- 初始标记：暂停所有其他线程，记录下与root直接相连的对象，速度很快
- 并发标记：同时开启垃圾收集线程和用户线程，用一个闭包结构记录可达对象。值得注意的是，在本阶段结束，闭包结构不能保证将所有的可达对象都包含，因为用户线程会不断更新引用域，所以垃圾收集线程无法保证可达性分析的实时性，算法会跟踪发生引用更新的地方
- 重新标记：暂停所有其他线程，时间会比初始标记稍长一些，但远比并发标记时间短；在此阶段对并发标记期间用户进程继续运行导致标记变动的对象进行修正
- 并发清除：开始用户线程和垃圾回收线程对标记区域进行清除

CMS收集器的优缺点：

- 并发收集、低停顿，能够提供良好的用户体验
- 对CPU资源敏感
- 无法处理浮动垃圾
- 使用的标记-清除算法结束时产生大量的空间碎片，会导致堆内存不规整

#### G1收集器

G1（Garba-First）收集器是一款面向服务器的收集器，==主要针对配备了多处理器和大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量的特性==

运作过程主要有初始标记、并发标记、最终标记、筛选回收

G1收集器具有以下特点：

- 并行与并发：G1能够充分利用CPU、多核环境下的硬件优势，使用多个CPU或CPU核心来缩短停顿时间，在收集器需要停顿其他线程时，G1收集器可以通过并发的方式让用户线程继续执行

- 分代收集：尽管G1收集器不需要其他收集器配合就能完成对堆的管理，但依旧保留了分代的概念
- 空间整合：从整体来看，G1时基于标记-整理算法实现的收集器；从局部看是基于复制算法实现的
- 可预测的停顿：与CMS一样都关注降低时间停顿，但是G1处理追求低停顿的同时还能让使用者明确指定在一个时间片段内

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的区域，这种回收方式quebaoG1收集器在有限的时间内尽可能高效率进行回收
