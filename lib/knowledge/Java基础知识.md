# Java基础知识

[TOC]

## Java语言的特点

1.简单易学

2.面向对象

3.平台无关性（Java虚拟机实现平台无关性）

4.可靠性

5.安全性

6.支持多线程

7.支持网络编程而且方便

8.编译与解释并存



ps：

- 平台无关性是指Java“==一次编译，永久运行==”，Java编译创建的是可执行的二进制程序，能够不加改变的运行于多个平台；原因是Java程序都要被编译成统一的class文件，并通过JVM将其转成二进制文件，==JVM屏蔽了底层操作系统和硬件的差异==
- C++没有内置的多线程机制，必须调用操作系统的多线程功能来进行多线程程序设计，Java本身就提供了多线程支持；C++11开始也引入了多线程库
- Java程序要先编译成统一的class文件（字节码），再由Java解释器进行解释执行，所以是编译与解释并存



## 面向对象与面向过程的区别

面向过程性能较高。面向过程语言大多都是直接编译成机器码然后在电脑上执行的。



面向对象易维护、易复用、易扩展。因为面向对象具有封装、继承、多态等特性，可以设计出高内聚低耦合的系统，系统更加灵活和易于维护。



## Java和C++的区别

- Java和C++都是面向对象的语言，都支持封装、继承、多态
- Java不提供指针直接访问内存，程序内存更加安全
- Java类是单继承的，接口可以多继承；C++支持多重继承
- Java有自动内存管理机制，不需要手动释放内存



## JVM JDK JRE简答

JVM	Java虚拟机

JDK	Java Deveployment Kit

JRE	Java Runtime Enviroment



- JVM

JVM是运行Java字节码的虚拟机，==JVM使得Java具有平台无关性，但是JVM本身有针对不同系统的特定实现==

> Java程序运行过程

![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

> 字节码

字节码是指Java可以理解的代码，不面向任何处理器，只面向处理机；

==字节码在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点==

ps：解释型语言逐行进行解释执行，热点代码的存在会使得执行效率低；热点代码是指频繁调用的方法和代码块



- JDK和JRE

JDK是功能齐全的Java SDK(Software Development Kit)。JDK拥有JRE拥有的一切，还有编译器(javac)和工具(javadoc、jdb)，能够创建和编译程序



JRE是Java运行时所需的环境，包括运行已编译Java程序所需的所有内容，如JVM、Java类库、Java命令等，但是JRE不能用来创建新程序



简单来说，在使用Java进行编程等开发工作时需要用到JDK，如果只是运行一下Java程序JRE就可以了

如果使用JSP部署Web应用，从技术上讲是在应用服务器上运行Java程序，因为程序服务器会将JSP转换问Java servlet，并且需要JDK对servlet进行编译



## 字符型常量与字符串常量的区别

- 形式上：一个用单引号，一个用双引号
- 含义上：字符型常量相当于一个整型数(Ascii码)，能够参与表达式运算；字符串常量表示一个地址(字符串存放的位置)
- ==字符型占2个字节==；字符串占若干个(至少一个结束符)

ps：Java中char型占2个字节



## 重载与重写的区别

- 重载	Overload

在同一个类中，方法名相同，函数签名不同，返回值和访问修饰符可以不同，发生在编译时

- 重写	Overwrite

在子类中，方法名、函数签名相同，返回值范围、访问修饰符范围小于等于父类、抛出异常范围大于等于父类；

如果父类中方法的访问修饰符为private，子类不能进行重写



## 面向对象编程三大特性

- 封装	通过访问修饰符对属性和方法进行封装，只暴露部分必要的属性和接口
  - 良好的封装可以减少代码的耦合性
  - 类的内部实现可以自由修改
  - 具有清晰的对外接口

- 继承    子类继承父类的非私有属性和方法
  - 提高了代码的重用性
  - 使得扩展和维护容易实现
  - 是多态的前提
  - 但是破坏了封装，增强了类之间的耦合性

- 多态    不同的实例具有不同的表达方式，引用变量所指向的具体类型和行为都不确定而是在程序运行时才确定
  - 提高了扩展性和代码的重用性



## String StringBuffer StringBuilder

- String

在String类中使用final修饰字符数组来保存关键字，因此String是不可变的



- StringBuffer StringBuilder

 两者都继承自AbstractStringBuilder，区别在于

==StringBuffer对方法和调用的方法加了同步锁，所以是线程安全的==

StringBuilder是非线程安全的



每次对String类型进行改变时都会生成一个新的String对象，然后将指针指向新的String对象

StringBuffer对对象本身进行操作

相同情况下StringBuilder比StringBuffer性能提升10%-15%，但是线程不安全



## 静态方法

Java静态方法是在类加载时创建的，因此不依赖于对象，可以不通过对象调用

静态方法中不能调用非静态方法，也不能访问非静态成员

如果静态方法中要使用非静态方法/属性，可以创建一个实例然后通过对象进行调用



## 在Java中定义一个不做事的无参构造方法的作用

子类在执行构造函数之前，如果没有通过super()指定调用父类特定的构造函数，会默认调用父类的无参构造函数；如果父类只定义了有参构造函数，子类恰好又用super()指明调用父类的有参构造函数，编译器找不到父类的无参构造函数，因此会报错



## 接口和抽象类的区别

- 接口中除了static和final不能有其他属性
- 接口能够多继承（可以一个类实现很多接口，接口本身也能够通过extends扩展多个接口），抽象类不能
- 从设计层面来说，抽象类是对类的抽象，是一种模板设计；接口是对行为的抽象，是一种行为的规范



## 成员变量和局部变量的区别

- 成员变量属于类，局部变量属于方法或方法参数
- 局部变量不能被访问修饰符和static修饰，成员变量和局部变量都能被final修饰
- 成员变量属于实例，对象存在堆内存；局部变量属于方法，存在栈内存



## 对象实例与对象引用有什么区别

- 对象实例创建出来是放在堆内存中的，对象引用是放在栈中的

- 一个对象引用可以指向0或1个对象实例；1个对象实例可以被多个对象引用指向



## 构造方法的特点

- 方法名与类名相同
- 没有返回类型（不能用void声明构造函数）

- 在生成实例时自动执行。无需调用



## 静态方法与实例方法的区别

- 静态方法在类加载的时候就声明了，实例方法在创建实例时才被声明；因此调用静态方法无需创建对象
- 静态方法只能访问静态成员（静态变量和静态方法）



## ==和equals()的区别

- ==

==判断的是两个对象的地址是否相同，即两个对象是否是同一个对象



对于常量来说，==常量会被放在常量池中==（有且只有一个），在使用一个常量时会现在常量池中查找是否有这样一个常量，如果有，就把这个地址上的对象赋给那个引用，也就是说相同常量其实共用一个对象



- equals()

==在equals()未被重写的情况下，equals()等价于====

在equals()被重写的情况下(如String)，equals()比较的是内存里的内容是否相同

```java
public class test1 { 
    public static void main(String[] args) { 
        String a = new String("ab"); // a 为一个引用 
        String b = new String("ab"); // b为另一个引用,对象的内容一样 
        String aa = "ab"; // 放在常量池中 
        String bb = "ab"; // 从常量池中查找 
        if (aa == bb) // true 
            System.out.println("aa==bb"); 
        if (a == b) // false，非同一对象 
            System.out.println("a==b"); 
        if (a.equals(b)) // true 
            System.out.println("aEQb"); 
        if (42 == 42.0) { // true 
            System.out.println("true"); 
        } 
    } 
}
```



## hashCode()与equals()

> hashCode()

hashCode()函数是用来获取哈希码，也成称为散列码；返回值是一个int整数，哈希码的作用时确定对象在哈希表中的索引位置。



> hashCode()何时发挥作用？

 在会创建”类对应的散列表“时发挥作用，打个比方，将Person类的对象加入到散列表HashSet中时，hashCode()会在其中发挥作用：

- 在将对象加入到散列表时会先查看散列码来检查是否有重复元素
- 若散列码不同，则直接加入到散列表；若相同，则调用equals()函数检查是否真的相同，如果不同再散列到其他位置

这样的好处是减少了equals()函数的调用次数，提高了执行速度

==若想要hashCode()在上述过程中发挥作用，则必须要对Person类的hashCode()和equals()方法进行重写==



> hashCode()与equals()

对于会创建“类对应的散列表”的情况来说

- 如果两个对象相等，则hashCode()一定相等
- 两个对象hashCode()相等，但两个对象不一定相等
- ==因此equals()被重写，hashCode()一定也要被重写==
- ==hashCode()是对堆上的对象产生的特定的值，如果没有重写hashCode()，两个对象无论如何都不会相等（因为两个对象不会指向相同的数据）==



## 线程、进程、程序以及它们之间的关系

- 进程

进程是程序的一次执行过程（动态的），也就是正在执行中的程序。进程逐一执行程序中的指令，并且占有某些系统资源（CPU时间、内存、I/O等）的使用权



- 线程

线程又被称为轻量级进程，是比进程更小的执行单位



- 程序

程序是含有指令和数据的文件，被存储在磁盘或其他存储设备上，也就是静态的代码



==进程是系统资源分配的基本单位；==

==进程是系统调度的基本单位；在引入线程的系统中，线程可以取代进程成为系统调度的基本单位；==

==进程与线程的区别在于各进程之间是相互独立的，线程则不一定：==

==不同的进程使用不同的地址空间，同一进程下的线程共用一片地址空间（因此可能会相互影响==）



## final关键字

final关键字主要使用在三个地方：变量、方法、类

- 对于一个final变量，如果该变量是一个基本数据类型，则该变量的数值一经初始化后就不能改变了；如果该变量是引用类型的变量，则对其初始化后就不能让其指向另一个对象了
- ==对于一个final方法，任何继承类都不能再修改其含义；所有private方法都被隐式指定为final==
- 对于一个final类，表示这个类不能够被继承，类中的所有方法都是final方法



## Java异常

> Java异常类层次结构图

![Java异常类层次结构图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)

Error是程序无法处理的错误，一般和JVM有关



Exception是程序本身可以处理的异常



## 从键盘获取输入的方式

- Scanner

```java
Scanner scanner = new Scanner(System.in);
String str = scanner.nextLine();
scanner.close();
```



- BufferedReader

```java
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
String str = bufferedReader.readLine();
```



## 字符流与字节流

收发信息的最小存储单元都是字节



字符流事实上是由JVM将字节流转换得来的，这个过程是比较耗时的，并且==如果不知道编码类型的情况下很容易出现乱码==，因此I/O流就有了一个直接操作字符的接口，方便直接对字符流进行操作。对于音频、图像等文件传输使用字节流就好，如果涉及到字符使用字符流会更合适。



## BIO、NIO、AIO

首先要知道，BIO、NIO、AIO是Java对操作系统各种I/O模式的封装，是Java的API，根据实际需要使用不同的API



> 同步和异步

- 同步：在发起一个调用后，被调用者未处理完请求之前，调用不返回
- 异步：在发起一个调用后，立刻得到被调用者的回应表示已收到请求；在被调用者未返回结果前可以处理其他请求，被调用者通过事件、回调等机制来通知调用者返回结果



> 阻塞与非阻塞

- 阻塞是指在发起一个请求后，当前进程会被挂起，调用者一直等待返回结果
- 非阻塞是指调用者发起一个请求后不必等待，可以先去处理其他请求



- BIO(Blocking I/O)

同步阻塞I/O模式，数据的读写必须阻塞在一个线程内等待完成

> 传统BIO

![传统BIO通信模型图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2.png)

<center style="color:#C0C0C0">传统BIO通信模型</center>

BIO通信模型通常由一个Acceptor线程来监听客户端连接，服务端通过accept()方法等待接受客户端的监听请求，请求一旦接收就可以建立通信套接字，并在套接字上进行读写操作，==此时不再接受其他客户端的请求，直到当前连接的客户端操作执行完==

BIO一次只能处理一个客户端的请求，主要原因是三个主要的函数socket.accept()、socket.read()、socket.write()都是同步阻塞的；**在接收到客户端请求后为客户端创建一个新的线程，线程进行链路处理通过输出流返回应答给客户端，然后线程销毁**，这就是典型的==一请求一应答通信模型==

如果想让BIO通信模型能够同时处理多个客户端请求，就必须使用多线程（如上图所示），在每次接收到客户端请求时为每个客户端创建一个线程进行链路处理



**在传统BIO模型下，客户端并发访问量增加后会出现种种问题**

- 首先，在JVM中线程是宝贵的资源，线程的创建、销毁还有线程切换的成本都很高
- 对于Linux这样的操作系统来说，线程本质上就是个进程，因此创建和销毁都是重量级的系统调用
- 如果并发访问量增加会导致==线程数急剧膨胀==，可能会导致线程堆栈溢出、创建新线程失败等问题
- 如果某个连接不做任何事情的话，就会产生不必要的线程开销



> 伪异步IO





![伪异步IO模型图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3.png)

<center style = "color:#C0C0C0">伪异步IO通信模型</center>

为了解决同步阻塞I/O面临的问题，添加了==线程池机制==进行改善

**线程池**能够让线程的创建和回收的成本相对较低，而且可以有效控制线程数量，灵活调配线程资源



上图展示了一个通过**任务队列**和**线程池**实现的伪异步I/O通信模型

当有客户端接入时，将Socket封装成一个Task投递给线程池

线程池维护一个任务队列和多个活跃线程对任务进行处理

通过设置任务队列的大小和最大线程数来实现资源占用的可控



尽管如此，伪异步I/O通信模型只是避免了线程耗尽的问题，底层依旧是同步阻塞的I/O模型



- NIO(New I/O)

同步非阻塞I/O模型，是一种支持面向缓冲、基于通道操作的通信模型，提供了Channal、Selector、Buffer等抽象



> Non-blocking IO

==IO流是阻塞的，NIO流不是==

NIO能够进行非阻塞IO操作，例如，单线程从Channel读取数据到Buffer，同时可以继续做其他事；或者某单线程向某通道写入数据时，不必等到数据完全写入就能同时做其他事



> 3个核心组件/特性

**Buffer（缓冲）**

==IO是面向流的，NIO是面向缓冲区的==

在原I/O中，数据可以直接读写到Stream对象中；尽管有Buffer开头的扩展类，但也只是对流的包装

NIO直接对缓冲区进行读写，无论何时访问NIO中的数据都是通过缓冲区进行的



**Channel（通道）**

NIO通过通道进行读写

通道是双向的，可读也可写，而流只能单向操作

通道只能与Buffer进行交互，因此可以实现异步读写



**Selector（选择器）**

选择器用于使用单个线程处理多个通道，因此只需要较少的线程来处理通道

![一个单线程中Selector维护3个Channel的示意图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Slector.png)

<center style = "color:#C0C0C0">一个单线程维护三个Channel</center>



整个NIO体系还包含很多组件，上面三个只是NIO的核心API



- AIO(Asynchronous I/O)

异步非阻塞I/O模型

异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回不会堵塞，当后台处理完，操作系统会通知相应的线程进行后续操作



## 深拷贝和浅拷贝

- 浅拷贝

对基本的数据类型进行值传递，对引用数据类型进行引用传递（引用指向堆中同一个内容）

- 深拷贝

对基本的数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容（对应堆中不同的地址）



## Java集合框架常见问题

### List、Set、Map三者的区别

- List：有序存储一组不唯一的对象（可以有多个元素引用相同的对象）
- Set：集合（不会出现重复）
- Map：使用键值对进行存储，Key是唯一的，引用的对象可以重复



### ArrayList和LinkList的区别

- 线程安全问题：ArrayList和LinkList都是不保证线程安全的
- 底层实现：ArrayList的底层实际上是Object数组；==LinkList的底层是双向链表==
- 插入和删除：进行插入和删除操作的时间复杂度和底层是一样的，就是一个封装
- 快速随机访问：和底层一样，ArrayList支持随机访问，LinkList不支持
- 内存空间占用：ArrayList对空间花费主要在列表的尾部预留一部分空间；LinkList的空间花费在于每一个元素占用的空间都比ArrayList多



### RandomAccess接口

RandomAccess接口的源码实际上什么都没写，该接口相当于一个标识，实现了该接口的类都是支持随机访问的



### ArrayLists与Vector的区别

Vector类的所有方法都是同步的，也就是线程安全的；对于单个线程访问Vector的话，要在同步操作上耗费大量的效率；而ArrayList不是同步的，在不需要保证线程安全的情况下可以使用



### HashMap的底层实现

#### HashMap的存储结构

![jdk1.8之后的内部结构-HashMap](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg)

<center style = "color:#c0c0c0">Java 8之后HashMap的内部结构</center>

HashMap就是用哈希表来进行存储，哈希表处理冲突的方式有开放地址法和链地址法，HashMap使用链地址法处理冲突，简单来说就是数组加链表的方式，每个数组元素在经过Hash之后得到数组的下标，再把元素放在对应下标元素的链表中



==HashMap是通过数组+链表+红黑树实现的==（Java 8之后加了红黑树），当链表的长度大于阈值（默认是8）时，链表会转化为红黑树

> TreeMap、TreeSet、HashMap的底层都用到了红黑树，红黑树是为了解决二叉查找树的缺陷，因为二叉查找树会在某些情况下退化成线性结构



键值对的映射关系是通过HashMap的一个内部类Node来实现的（从HashMap的源码可以看得到），源码中有一个字段是Node数组，就是用来存放元素的哈希桶数组



#### HashMap存储过程

在向HashMap中添加一个新的元素时，要进行的操作依次如下：

- 调用Key那个对象所属类的hashCode()方法获取hashCode
- 通过Hash算法定位该键值对所属的存储位置
- 将新的元素加入HashMap（如果发生Hash碰撞还要进行冲突处理）



==HashMap的存取效率取决于元素在哈希桶数组中的分散程度==

- 哈希桶数组越大，元素越分散
- 在哈希桶数组的大小合适的前提下，Hash算法越好，元素越分散

因此需要一个时间成本和空间成本上的权衡，根据实际情况确定哈希桶数组的大小，在此基础上设计好的Hash算法来减少Hash碰撞



#### HashMap的扩容机制

==好的Hash算法和扩容机制能够控制map来使得Hash碰撞概率变小，哈希桶数组占用的空间又小==



在Hash算法的实现上，通过

> 在取余操作中，如果除数是2的幂次，则该操作等价于与其除数减一的与操作，即
>
> hash % length 等价于 hash & （length - 1）

将取余（%）用位运算（&）代替，能够提高计算效率

也就是，==Hash算法要求HashMap的长度一定是2的幂次方==



HashMap的扩容机制是指当HashMap中元素的数量超过容量时，就将容量扩大到原来的两倍

值得一提的是，和HashMap能够存储的元素数量有关的一个字段loadfactor是指负载因子，负载因子是对时间和空间效率的一个平衡，是当前数组大小和能够存储的键值对数量的一个比例关系



#### HashMap的长度

HashMap的长度是指哈希桶数组的长度length

==HashMap中length的长度一定是2的幂次方，这是一种非常规设计==，之所以这样做是在取模和扩容过程中做了优化，同时也是为了减少冲突

常规设计是将length的长度设为素数，因为素数导致冲突的概率会小于合数，例如HashTable的默认大小就是11（但是在扩容之后不能保证还是素数）



### HashMap和HashTable的区别

HashTable基本淘汰，不要用了

- 线程安全问题：HashMap是非线程安全的，HashTable是线程安全的；实际使用的时候用ConcurrentHashMap，也是保证线程安全的，而且对并发的支持更好
- 对Null的支持：HashMap中Key和Value都可以为null；HashTable中Key和Value都不能为null

- 初始容量和扩容机制：HashMap的初始长度是16，扩容时每次变为之前的两倍；HashTable的初始长度是11，每次扩容变为原来的2n+1
- 底层结构：在处理Hash冲突时使用链地址法，当链表长度大于阈值时，HashMap会将链表变成红黑树来提高查找效率，HashTable没有



### ConcurrentHashMap与HashTable的区别

两者都保证了线程安全

- 底层结构：HashTable和Java 8之前的HashMap一样是数组+链表；ConcurrentHashMap和Java 8之后的HashMap一样是数组+链表+红黑树
- 实现线程安全的方式：ConcurrentHashMap在以前是采用分段锁来确保线程安全和控制并发访问的，之后使用synchronized和CAS来操控；HashTable使用synchronized来保证线程安全，但是效率非常低下，当一个线程访问时，其他线程同步访问可能会陷入阻塞或轮询状态；因此ConcurrentHashMap可以看作是线程安全并且对并发访问优化过的HashMap



### HashMap与HashSet的区别

HashSet的底层实际上是基于HashMap来实现的，除了一些自己必须实现的方法外都是直接调用HashMap的方法

|        HashMap        |                        HashSet                         |
| :-------------------: | :----------------------------------------------------: |
|      实现Map接口      |                      实现Set接口                       |
|      存储键值对       |                       仅存储对象                       |
|       put()添加       |                       add()添加                        |
| 使用Key来计算hashcode | 使用对象来计算hashcode，用equals来判断两个对象是否相等 |

HashSet检查重复的方法：

- 先调用hashCode()方法来计算hashcode
- 比较hashcode
- hashcode不等，直接添加；hashcode相等，用equals()判断后再决定添加与否



### Comparable和Comparator的

- 接口java.lang.Comparable有一个compareTo(Object obj)方法来进行排序
- 接口java.util.Comparator有一个compare(Object obj1, Object obj2)方法来进行排序

要实现对某个集合进行自定义排序时需要重写compareTo()方法或comepare()方法
