# 操作系统基础知识

[TOC]

## 内核态和用户态

为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态

内核态：操作系统管理程序执行时处理器的状态，能够执行包括特权指令在内的一切指令，能够访问系统内的所有存储空间

用户态：用户进程执行时处理器的状态，不能执行特权指令，只能访问用户地址空间

用户进程运行在用户态；操作系统内核运行在 内核态



## 内核态和用户态的切换

- 系统调用
- 异常，例如缺页异常
- 设备的中断信号，例如I/O设备处理完后，系统中断当前进程来抢占cpu的执行权



## 并发与并行

> 并发是指在**同一时间间隔内**执行不同的任务
>
> 并行是指在**同一时刻**执行不同的任务，不同的任务可以互不影响的执行下去

> 并发一般是一个执行单元在不同的任务之间进行切换
>
> 并行一般是多个执行单元同时执行不同的任务

> 并发能够获得更好的用户体验和系统资源利用率，但是并不能在真正意义上提高计算速率
>
> 并行是真正意义上提高了系统的计算速率（因为有多个执行单元）



## 同步、异步、阻塞、非阻塞

同步：在发起一个调用后，被调用者未处理完请求之前，调用不返回

异步：在发起一个调用后，立刻得到被调用者的回应表示已收到请求；在被调以哦那个这返回请求结果之前，调用者可以处理其他请求，被调用者通过事件，回调等机制来通知调用者返回结果



阻塞：在线程发起一个请求后，该线程会被挂起，调用者一直到等待处理结果

非阻塞：调用者发起请求后不必等待，可以先去处理其他请求



**同步、异步和阻塞、非阻塞不能混为一谈**

同步、异步强调的是消息通信机制；阻塞、非阻塞强调的是程序在等待调用结果时的状态

对于同步、异步来说：同步是被调用者主动等待被调用者的返回结果；异步是被调用者在处理完请求后通过各种机制（例如事件、同步机制）来通知调用者；

对阻塞、非阻塞来说：阻塞是指在请求发出后，被调用者返回前，调用者一直被挂起无法继续执行；非阻塞是指调用不会影响线程的执行

同步调用的时候，只有被调用者返回，调用者才能继续之后的代码，在这期间线程处于激活状态，但是什么事都没做，属于真正意义上的白白浪费资源；阻塞调用的时候，被调用者没有立刻返回结果，线程会被挂起直到被调用者返回，线程才重新就绪



## 进程与线程

### 概念

进程是指一次程序的执行活动，是系统调度和资源分配的基本单位

线程是进程中一个可调度的实体 ，是处理器调度和分配的最小单位                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

### 区别

- 进程是系统资源分配的最小单位；线程是系统调度的最小单位
- 不同进程间相互独立，有独立的内存空间；同一进程下的线程共享一片内存空间
- 线程被称为轻量级进程，线程的创建，终止，上下文切换都比进程要快得多

### 多线程的意义

- 首先，在以前一个进程中只有一个线程，也就是只有一个控制流，在该线程发生阻塞时整个进程会被挂起，进程的其他任务即便不依赖等待的资源也不能执行；多线程的出现能够提高进程的工作效率
- 然后，为什么是多线程而不是多进程？进程的创建、终止、上下文切换的开销都比线程要高得多
- 对于不同进程，他们拥有独立的地址空间，进行数据传递只能通过进程间通信；同一进程中的线程共享一片地址空间，线程之间的数据可以直接读写不需要经过内核



## 进程的状态转换

![image-20211223110739048](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20211223110739048.png)

运行态：进程实际占用CPU

就绪态：进程准备就绪，其他进程正在运行，等待系统调度

阻塞态：缺少继续运行下去的条件，除非外部事件发生

1.运行→阻塞：进程等待事件的发生（资源分配、I/O等）

2.运行→就绪：系统将CPU分配给其他进程，运行中的进程进入就绪态等待使用CPU

3.就绪→运行：系统将CPU分配给该进程

4.阻塞→就绪：进程等到了继续运行下去的资源，进入就绪态等待调度



## 进程间通信

- 管道，是一种半双工的通信方式，数据只能单向流动；匿名管道只能在具有亲缘关系的进程间通信，命名管道能够在不带有亲缘关系的进程间通信
- 系统IPC：
  - 消息队列
  - 共享内存：映射一段能够被多个进程访问的内存空间，针对的是其他进程间通信方法效率低的问题，往往和信号量等其他通信机制结合来实现互斥、同步等
  - 信号量：常作为一种锁机制，用来控制多个进程对共享资源的访问
- 套接字：套接字可用于不同机器之间的进程间通信



## 进程调度

### 何时进行调度

- 在创建一个新进程后决定运行父进程还是子进程
- 当一个进程退出时
- 当一个进程阻塞时
- 在一个I/O中断发生时
- 抢占式调度中具有更高优先级的进程就绪时
- 分配给当前进程的时间片用完时

### 调度算法的目标

对于所有系统

- 公平-所有进程公平占有CPU
- 策略强制执行-必须遵守指定策略
- 平衡-系统各个部分都要忙碌（CPU、I/O、磁盘等）

对于批处理系统

- 吞吐量-单位时间最大作业数
- 周转时间-提交到终止间的最短时间
- CPU利用率

对于交互式系统

- 响应时间
- 均衡性

实时系统

- 满足截止时间
- 可预测性

### 调度算法

非抢占式调度：进程一直运行直到进程被阻塞或者进程自行释放CPU；发生时钟中断时不会进行调度

抢占式调度：进程运行到固定时段的最大值，时间片段的末尾发生时钟中断，CPU控制返回给调度程序

对于批处理系统

- 先到先服务
- 最短作业优先
- 最短剩余时间优先
- 最高响应比优先

对于交互式系统

- 时间片轮转调度
- 优先级调度
- 多级队列调度



## 守护进程、孤儿进程、僵尸进程

守护进程

- 守护进程就是在后台运行，不与任何终端相关联的进程，通常在系统启动时就在运行了，能够处理一些系统级的任务

孤儿进程

- 子进程还未结束，父进程先终止了，子进程会被托孤给init进程

僵尸进程

- 进程终止后进入僵死状态，通知父进程自己终止后才能完全消失，倘若父进程还没有获取其状态，这个进程就被称为僵尸进程；僵尸进程会占用一定的系统资源并保留一些概要信息供父进程查询

避免僵尸进程的方法

- 父进程周期性检查子进程的状态
- 通过信号量通知父进程进行回收
- 杀死父进程将僵尸进程变成故而孤儿进程，由initi进程进行回收



## 进程终止的方式

5种正常终止

- 从main函数返回
- 调用exit
- 调用\_exit或\_Exit
- 最后一个线程从其启动历程返回
- 最后一个线程调用pthread_exit

3中异常终止

- 调用abort()
- 接受一个信号并终止
- 最后一个线程对取消请求做出响应



## 死锁

死锁是因为进程在运行过程中因争夺资源而造成的一种僵局，当陷入这种僵局，若无外力作用，进程都无法继续向前推进

<img src="https://img-blog.csdnimg.cn/20201230161553526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05lcmRf,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

### 产生原因

- 竞争不可抢占式资源
- 竞争临界资源
- 进程间的推进顺序非法

### 必要条件

- 互斥条件：一段时间内某一资源仅被某一进程占用
- 请求和保持条件：进程对于以获得的资源保持不放
- 不可抢占条件：对进程已获得但是未使用完的资源，系统不可剥夺
- 环路等待条件：必然存在一个进程-资源的环形等待链

### 解除死锁的基本方法

- 鸵鸟算法
- 检查和恢复
  - 用一张有向图描述当前进程和竞争资源的关系，用合适的算法检查环路
  - 发生死锁时破坏环路，通过**抢占资源、回滚、杀死进程**等方法

### 预防死锁

破化死锁的必要条件即可

- 资源一次性分配（破坏请求条件）
- 只要有一个资源得不到分配，也不给该进程分配其他资源（破坏等待条件）
- 可抢占资源，当进程资源未被满足，释放已占有的资源（破环不可抢占条件）
- 资源有序分配，进程按合理顺序请求资源（破坏环路条件）

### 避免死锁

- 资源轨迹图
- 银行家算法



## 物理地址，逻辑地址，虚拟内存

![img](https://pic3.zhimg.com/80/v2-57761263ddb2f0273c6d88884f7fdf46_720w.jpg)

- 物理地址

物理地址是指物理内存上的地址，能够直接定位到物理内存上的位置

- 逻辑地址（有时候又叫虚拟地址）

编译器对程序进行编译时会生成代码段和数据段，逻辑地址就是每条代码/数据对应的段内偏移量，是经过分段、分页机制处理之前的地址

- 虚拟内存

虚拟内存是指计算机呈现出比实际拥有的内存要大得多的内存量，因此允许运行比实际内存大得多的程序。



## 分段和分页

分段和分页都是内存管理机制，当不存在分段分页机制时，逻辑地址直接映射为物理地址，当存在分段分页机制时，逻辑地址要经过一些映射才能变成物理地址

### 分段机制

分段机制将虚拟地址空间内的虚拟内存组织成一些长度可变的内存单元

![img](http://images.cnitblog.com/blog/525372/201401/211729348199.png)

<center style = "color:#c0c0c0">逻辑地址到线性地址的变换过程</center>

### 分页机制

分页机制将虚拟地址空间分成固定大小的”页“，将部分程序引用到的页映射到物理内存中（也就是页框）

![img](http://images.cnitblog.com/blog/525372/201401/211729570070.png)

<center style = "color:#c0c0c0">线性地址到物理地址的变换过程</center>

### 分段机制和分页机制的区别

- 分段使用了大小可变的块来管理内存（因为分段的初衷就是希望程序员不用管理表扩张和收缩）；分页则是使用固定大小的内存块

- 分页使用固定大小的内存块更适合管理物理内存；分段使用大小可变的块更适合处理系统复杂的逻辑分区
- 段表存储在线性地址空间；页表存储在物理地址空间



## 页面置换算法

- 先进先出页面置换算法

置换最先调入内存的页面；实现简单但性能较差，有可能置换出去的页面是经常访问的页面

- 第二次机会页面置换算法

在FIFO的基础上，寻找最近未被使用过的页面；但是需要频繁的在页面的链表结构中移动，效率和性能较低

- 时钟页面置换算法

在第二次机会页面置换算法的基础上，将链式结构替换成环形链表

- 最近最少使用页面置换算法

根据局部性原理，最近访问过的页面很有可能再被访问，因此替换掉最近一段时间最少使用的页面；但实现难度大

- 最不常使用页面置换算法

对访问次数最少的页面进行置换；算法开销大，很难置换掉一开始频繁使用但以后不常使用的页面

- 工作集页面置换算法



## 缓冲区溢出

缓冲区溢出是指向缓冲区填充了多于其容量上限的内容，使得原本在栈桢中的内容被淹没

根据淹没的内容会产生不同的后果：

- 淹没局部变量，可能会改变程序原本的执行流程
- 淹没ebp的值，修改了函数执行结束后要恢复的栈指针，最终可能导致栈帧失去平衡
- 淹没返回地址，可能会使程序跳转到意想不到的位置（往往通过缓冲区溢出进行攻击就是用过这种方式）
- 甚至有可能淹没上级函数的栈帧，就会影响到上级函数的执行



